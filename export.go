package main

import (
	"archive/zip"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"strings"
	"time"
)

// === Static Site Export ===

type ExportOptions struct {
	SiteID        string
	IncludeAssets bool
	Theme         string
	Format        string // "zip", "html", "json", "rss"
}

// ExportSiteAsStatic generates a complete static website from a site
func ExportSiteAsStatic(opts ExportOptions) ([]byte, error) {
	buf := new(bytes.Buffer)
	zw := zip.NewWriter(buf)

	// Get site info
	var site Site
	err := db.QueryRow(`SELECT id, name, description FROM sites WHERE id = ?`, opts.SiteID).
		Scan(&site.ID, &site.Name, &site.Description)
	if err != nil {
		return nil, fmt.Errorf("site not found: %v", err)
	}

	// Get all published nodes
	rows, err := db.Query(`
		SELECT id, type, path, title, content, slug, canonical_uri, body, metadata, status
		FROM nodes 
		WHERE site_id = ? AND (status = 'published' OR status = 'public')
		ORDER BY created_at DESC
	`, opts.SiteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var nodes []Node
	for rows.Next() {
		var n Node
		rows.Scan(&n.ID, &n.Type, &n.Path, &n.Title, &n.Content, &n.Slug, &n.CanonicalURI, &n.Body, &n.Metadata, &n.Status)
		nodes = append(nodes, n)
	}

	// Generate index.html
	indexHTML := generateIndexPage(site, nodes)
	f, _ := zw.Create("index.html")
	io.WriteString(f, indexHTML)

	// Generate individual pages
	for _, node := range nodes {
		pageHTML := generateNodePage(site, node)
		filename := fmt.Sprintf("%s.html", node.Slug)
		if node.Slug == "" {
			filename = fmt.Sprintf("%s.html", node.ID)
		}
		f, _ := zw.Create(filename)
		io.WriteString(f, pageHTML)
	}

	// Add CSS
	cssFile, _ := zw.Create("style.css")
	io.WriteString(cssFile, getDefaultCSS())

	// Add RSS feed
	rssFile, _ := zw.Create("feed.xml")
	io.WriteString(rssFile, generateRSSFeed(site, nodes))

	// Add JSON API
	jsonFile, _ := zw.Create("api.json")
	jsonData, _ := json.Marshal(map[string]interface{}{
		"site":  site,
		"nodes": nodes,
	})
	io.WriteString(jsonFile, string(jsonData))

	// Add manifest
	manifestFile, _ := zw.Create("manifest.json")
	manifest := map[string]interface{}{
		"name":             site.Name,
		"short_name":       site.Name,
		"description":      site.Description,
		"start_url":        "/",
		"display":          "standalone",
		"background_color": "#ffffff",
		"theme_color":      "#4f46e5",
	}
	manifestData, _ := json.Marshal(manifest)
	io.WriteString(manifestFile, string(manifestData))

	zw.Close()
	return buf.Bytes(), nil
}

func generateIndexPage(site Site, nodes []Node) string {
	var nodesList strings.Builder
	for _, node := range nodes {
		slug := node.Slug
		if slug == "" {
			slug = node.ID
		}
		excerpt := truncateString(node.Content, 200)
		nodesList.WriteString(fmt.Sprintf(`
			<article class="card">
				<h2><a href="%s.html">%s</a></h2>
				<p>%s</p>
				<div class="meta">Type: %s</div>
			</article>
		`, slug, node.Title, excerpt, node.Type))
	}

	return fmt.Sprintf(`<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>%s</title>
	<meta name="description" content="%s">
	<link rel="stylesheet" href="style.css">
	<link rel="alternate" type="application/rss+xml" title="%s Feed" href="feed.xml">
	<link rel="manifest" href="manifest.json">
</head>
<body>
	<header>
		<h1>%s</h1>
		<p class="tagline">%s</p>
		<nav>
			<a href="/">Home</a>
			<a href="feed.xml">RSS</a>
			<a href="api.json">API</a>
		</nav>
	</header>
	<main>
		<div class="content-grid">
			%s
		</div>
	</main>
	<footer>
		<p>Generated by Veil • %s</p>
	</footer>
</body>
</html>`, site.Name, site.Description, site.Name, site.Name, site.Description, nodesList.String(), time.Now().Format("2006-01-02"))
}

func generateNodePage(site Site, node Node) string {
	content := markdownToHTML(node.Content)

	return fmt.Sprintf(`<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>%s - %s</title>
	<meta name="description" content="%s">
	<link rel="stylesheet" href="style.css">
	<link rel="canonical" href="%s">
</head>
<body>
	<header>
		<h1><a href="/">%s</a></h1>
		<nav>
			<a href="/">Home</a>
			<a href="feed.xml">RSS</a>
		</nav>
	</header>
	<main>
		<article class="post">
			<h1>%s</h1>
			<div class="meta">Type: %s | URI: %s</div>
			<div class="content">
				%s
			</div>
		</article>
	</main>
	<footer>
		<p><a href="/">← Back to %s</a></p>
		<p>Generated by Veil • %s</p>
	</footer>
</body>
</html>`, node.Title, site.Name, truncateString(node.Content, 200), node.CanonicalURI,
		site.Name, node.Title, node.Type, node.CanonicalURI, content, site.Name, time.Now().Format("2006-01-02"))
}

func getDefaultCSS() string {
	return `
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
	line-height: 1.6;
	color: #1e293b;
	background: #f8fafc;
}
header {
	background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
	color: white;
	padding: 3rem 2rem;
	text-align: center;
}
header h1 { font-size: 2.5rem; margin-bottom: 0.5rem; }
header h1 a { color: white; text-decoration: none; }
.tagline { opacity: 0.9; font-size: 1.1rem; }
nav { margin-top: 1.5rem; }
nav a {
	color: white;
	text-decoration: none;
	margin: 0 1rem;
	padding: 0.5rem 1rem;
	border: 1px solid rgba(255,255,255,0.3);
	border-radius: 4px;
	transition: all 0.3s;
}
nav a:hover { background: rgba(255,255,255,0.2); }
main {
	max-width: 1200px;
	margin: 2rem auto;
	padding: 0 2rem;
}
.content-grid {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
	gap: 2rem;
	margin: 2rem 0;
}
.card {
	background: white;
	padding: 2rem;
	border-radius: 8px;
	box-shadow: 0 1px 3px rgba(0,0,0,0.1);
	transition: all 0.3s;
}
.card:hover {
	box-shadow: 0 4px 12px rgba(0,0,0,0.15);
	transform: translateY(-2px);
}
.card h2 { margin-bottom: 0.5rem; font-size: 1.5rem; }
.card h2 a { color: #4f46e5; text-decoration: none; }
.card h2 a:hover { text-decoration: underline; }
.card p { color: #64748b; margin-bottom: 1rem; }
.meta {
	font-size: 0.875rem;
	color: #94a3b8;
	margin-top: 1rem;
}
.post {
	background: white;
	padding: 3rem;
	border-radius: 8px;
	box-shadow: 0 1px 3px rgba(0,0,0,0.1);
	max-width: 800px;
	margin: 0 auto;
}
.post h1 { font-size: 2.5rem; margin-bottom: 1rem; color: #0f172a; }
.content { margin-top: 2rem; }
.content h1, .content h2, .content h3 { margin: 2rem 0 1rem; }
.content p { margin-bottom: 1rem; }
.content a { color: #4f46e5; }
.content code {
	background: #f1f5f9;
	padding: 0.2rem 0.4rem;
	border-radius: 3px;
	font-family: 'Courier New', monospace;
}
.content pre {
	background: #1e293b;
	color: #e2e8f0;
	padding: 1rem;
	border-radius: 6px;
	overflow-x: auto;
	margin: 1rem 0;
}
.content img { max-width: 100%; height: auto; border-radius: 6px; margin: 1rem 0; }
footer {
	text-align: center;
	padding: 3rem 2rem;
	color: #64748b;
	border-top: 1px solid #e2e8f0;
	margin-top: 4rem;
}
footer a { color: #4f46e5; text-decoration: none; }
footer a:hover { text-decoration: underline; }
@media (max-width: 768px) {
	.content-grid { grid-template-columns: 1fr; }
	header h1 { font-size: 2rem; }
	.post { padding: 2rem 1rem; }
}
`
}

func generateRSSFeed(site Site, nodes []Node) string {
	var items strings.Builder
	for _, node := range nodes {
		if node.Type == "post" || node.Type == "page" {
			items.WriteString(fmt.Sprintf(`
		<item>
			<title>%s</title>
			<link>%s</link>
			<description>%s</description>
			<guid>%s</guid>
			<pubDate>%s</pubDate>
		</item>
			`, node.Title, node.Slug+".html", truncateString(node.Content, 300),
				node.CanonicalURI, time.Now().Format(time.RFC1123Z)))
		}
	}

	return fmt.Sprintf(`<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
	<channel>
		<title>%s</title>
		<description>%s</description>
		<link>./</link>
		<lastBuildDate>%s</lastBuildDate>
		%s
	</channel>
</rss>`, site.Name, site.Description, time.Now().Format(time.RFC1123Z), items.String())
}

func truncateString(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}
